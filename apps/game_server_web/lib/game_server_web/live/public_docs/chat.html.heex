<!-- Chat -->
<div class="card bg-base-100 shadow-xl collapsed" data-card-key="chat">
  <div class="card-body">
    <h2 class="card-title text-2xl mb-4 flex items-center gap-3">
      <svg
        class="w-12 h-8 text-blue-500"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"
        />
      </svg>
      {doc_text("Chat")}
      <button
        type="button"
        data-action="toggle-card"
        data-card-key="chat"
        aria-expanded="false"
        class="btn btn-ghost btn-sm ml-auto"
        title={doc_text("Collapse/Expand")}
      >
        <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 8l4 4 4-4"
          />
        </svg>
      </button>
    </h2>

    <div class="space-y-4">
      <p class="text-sm text-base-content/80">
        {doc_text(
          "The chat system supports messaging within lobbies, groups, and between friends (direct messages). Messages can carry arbitrary metadata, support read cursors for tracking unread counts, and integrate with the hook pipeline for moderation."
        )}
      </p>

      <h3 class="font-semibold">{doc_text("Chat Types")}</h3>
      <ul class="list-disc pl-6 text-sm space-y-1 text-base-content/80">
        <li>
          <strong>lobby</strong>
          — {doc_text(
            "Messages sent within a lobby. Requires the sender to be a member of the lobby."
          )}
        </li>
        <li>
          <strong>group</strong>
          — {doc_text(
            "Messages sent within a group. Requires the sender to be a member of the group."
          )}
        </li>
        <li>
          <strong>friend</strong>
          — {doc_text(
            "Direct messages between two friends. Requires an accepted friendship and neither user has blocked the other."
          )}
        </li>
      </ul>

      <h3 class="font-semibold">{doc_text("API Endpoints")}</h3>
      <p class="text-sm text-base-content/80">
        {doc_text("All chat endpoints require authentication (Bearer token). Base path:")}
        <code class="font-mono">/api/v1</code>
      </p>

      <div
        class="bg-base-200 font-mono text-xs sm:text-sm p-4 rounded-lg overflow-auto"
        phx-no-curly-interpolation
      >
        <pre>
  Method   Path                 Description
  ──────   ────                 ───────────
  POST     /chat/messages       Send a message
  GET      /chat/messages       List messages (paginated)
  POST     /chat/read           Mark messages as read
  GET      /chat/unread         Get unread message count</pre>
      </div>

      <h3 class="font-semibold mt-3">{doc_text("Sending a Message")}</h3>
      <p class="text-sm text-base-content/80">
        <code class="font-mono">POST /api/v1/chat/messages</code>
      </p>
      <div class="bg-base-200 font-mono text-xs sm:text-sm p-4 rounded-lg overflow-auto">
        <pre phx-no-curly-interpolation>
# Request body
{
  "chat_type": "lobby",       # "lobby" | "group" | "friend"
  "chat_ref_id": "42",        # lobby id, group id, or friend's user id
  "content": "Hello everyone!",
  "metadata": {"color": "red"} # optional JSON metadata
}

# Response (201 Created)
{
  "data": {
    "id": 1,
    "content": "Hello everyone!",
    "metadata": {"color": "red"},
    "chat_type": "lobby",
    "chat_ref_id": "42",
    "sender_id": 7,
    "inserted_at": "2026-01-15T10:30:00Z"
  }
}</pre>
      </div>

      <h3 class="font-semibold mt-3">{doc_text("Listing Messages")}</h3>
      <p class="text-sm text-base-content/80">
        <code class="font-mono">GET /api/v1/chat/messages</code>
        — {doc_text(
          "Returns paginated messages for a chat. For friend chats, messages in both directions are returned."
        )}
      </p>
      <div class="bg-base-200 font-mono text-xs sm:text-sm p-4 rounded-lg overflow-auto">
        <pre phx-no-curly-interpolation>
# Query parameters
?chat_type=lobby&chat_ref_id=42&page=1&page_size=25

# Response
{
  "data": [ ... ],
  "meta": {
    "page": 1,
    "page_size": 25,
    "count": 25,
    "total_count": 148,
    "total_pages": 6,
    "has_more": true
  }
}</pre>
      </div>

      <h3 class="font-semibold mt-3">{doc_text("Read Cursors & Unread Counts")}</h3>
      <p class="text-sm text-base-content/80">
        {doc_text(
          "Track which messages a user has read with read cursors. The server stores the last-read message ID per user per chat."
        )}
      </p>
      <div class="bg-base-200 font-mono text-xs sm:text-sm p-4 rounded-lg overflow-auto">
        <pre phx-no-curly-interpolation>
# Mark as read: POST /api/v1/chat/read
{
  "chat_type": "lobby",
  "chat_ref_id": "42",
  "last_read_message_id": 150
}

# Get unread count: GET /api/v1/chat/unread
?chat_type=lobby&chat_ref_id=42

# Response
{ "unread_count": 12 }</pre>
      </div>

      <h3 class="font-semibold mt-3">{doc_text("Real-time Events")}</h3>
      <p class="text-sm text-base-content/80">
        {doc_text(
          "New messages are broadcast in real-time via PubSub. WebSocket channels automatically forward these events to connected clients."
        )}
      </p>
      <div
        class="bg-base-200 font-mono text-xs sm:text-sm p-4 rounded-lg overflow-auto"
        phx-no-curly-interpolation
      >
        <pre>
  Chat Type   PubSub Topic              Channel
  ─────────   ────────────              ───────
  lobby       chat:lobby:{lobby_id}     LobbyChannel  → "new_chat_message"
  group       chat:group:{group_id}     GroupChannel   → "new_chat_message"
  friend      chat:friend:{lo}:{hi}     UserChannel    → "new_chat_message"
              + user:{recipient_id}</pre>
      </div>
      <p class="text-sm text-base-content/80">
        {doc_text(
          "Friend DMs are broadcast to both the sorted-pair topic and each user's personal topic, so the recipient receives the message even without subscribing to the friend chat topic directly."
        )}
      </p>

      <h3 class="font-semibold mt-3">{doc_text("Elixir Context Functions")}</h3>
      <p class="text-sm text-base-content/80">
        {doc_text("The Chat context module provides functions for server-side chat operations:")}
      </p>
      <div class="bg-base-200 font-mono text-sm p-4 rounded-lg overflow-auto">
        <pre phx-no-curly-interpolation>
# Send a message (validates access, runs hook pipeline, broadcasts)
GameServer.Chat.send_message(user, %{
  "chat_type" => "lobby",
  "chat_ref_id" => lobby_id,
  "content" => "Hello!",
  "metadata" => %{"color" => "blue"}
})

# List messages (paginated, cached with 60s TTL)
GameServer.Chat.list_messages("lobby", lobby_id, page: 1, page_size: 50)

# List friend messages (bidirectional)
GameServer.Chat.list_friend_messages(user_a_id, user_b_id, page: 1)

# Mark messages as read (upsert cursor)
GameServer.Chat.mark_read(user_id, "lobby", lobby_id, last_message_id)

# Count unread messages
GameServer.Chat.count_unread(user_id, "lobby", lobby_id)

# Count unread friend DMs
GameServer.Chat.count_unread_friend(user_id, friend_id)

# Delete messages by IDs (for admin or moderation)
GameServer.Chat.delete_messages(user_id, [msg_id_1, msg_id_2])</pre>
      </div>

      <h3 class="font-semibold mt-3">{doc_text("Hook Pipeline (Moderation)")}</h3>
      <p class="text-sm text-base-content/80">
        {doc_text(
          "Chat messages pass through the hook pipeline before being persisted. Use the before_chat_message hook to filter, transform, or reject messages — ideal for profanity filters, rate limiting, or content moderation."
        )}
      </p>
      <div class="bg-base-200 font-mono text-sm p-4 rounded-lg overflow-auto">
        <pre phx-no-curly-interpolation>
# In your hooks module (implements GameServer.Hooks behaviour)
@impl true
def before_chat_message(user, attrs) do
  content = attrs["content"] || ""

  cond do
    String.length(content) > 500 ->
      {:error, :message_too_long}

    contains_profanity?(content) ->
      {:ok, Map.put(attrs, "content", censor(content))}

    true ->
      {:ok, attrs}
  end
end

# After hook fires asynchronously (logging, analytics, etc.)
@impl true
def after_chat_message(message) do
  Logger.info("Chat message #{message.id} sent by #{message.sender_id}")
  :ok
end</pre>
      </div>

      <h3 class="font-semibold mt-3">{doc_text("Caching")}</h3>
      <p class="text-sm text-base-content/80">
        {doc_text(
          "Message listings are cached using Nebulex with version-based invalidation. When a new message is sent, the cache version for that chat is incremented, automatically invalidating stale cached results. Cache TTL is 60 seconds."
        )}
      </p>

      <h3 class="font-semibold mt-2">{doc_text("Access Rules")}</h3>
      <ul class="list-disc pl-6 text-sm space-y-1 text-base-content/80">
        <li>
          <strong>{doc_text("Lobby chat:")}</strong>
          {doc_text("User must currently be in the lobby (user.lobby_id matches)")}
        </li>
        <li>
          <strong>{doc_text("Group chat:")}</strong>
          {doc_text("User must be a member of the group")}
        </li>
        <li>
          <strong>{doc_text("Friend chat:")}</strong>
          {doc_text(
            "Users must have an accepted friendship and neither can have blocked the other"
          )}
        </li>
        <li>
          {doc_text("Messages have a maximum content length of 4096 characters")}
        </li>
        <li>
          {doc_text("Metadata is optional and stored as a JSON map")}
        </li>
      </ul>
    </div>
  </div>
</div>
